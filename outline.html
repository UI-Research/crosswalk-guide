<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Geographic Crosswalks at Urban</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="outline_files/libs/clipboard/clipboard.min.js"></script>
<script src="outline_files/libs/quarto-html/quarto.js"></script>
<script src="outline_files/libs/quarto-html/popper.min.js"></script>
<script src="outline_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="outline_files/libs/quarto-html/anchor.min.js"></script>
<link href="outline_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="outline_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="outline_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="outline_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="outline_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Geographic Crosswalks at Urban</h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="what-are-geographic-crosswalks" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="what-are-geographic-crosswalks">What Are Geographic Crosswalks?</h2>
<p>Urban researchers often conduct analyses that require the use of data that contain geographic information. What do we do, though, when we have multiple data sources at different geographic levels, such as census tract, zip code, place, or state? What if we have data at one level of geography but do not have data at the geographic level we want represent? And how would we standardize geographies that change spatially over time? (Looking at you census tracts!)</p>
<p>We need a tool to transform data from one spatial level to another. This is a crosswalk! Geographic crosswalks, also called correlation lists, equivalency files, or geographic correspondence files, allow us to approximate data from one geographic level to another.</p>
<p><img src="www/images/crosswalk.png" class="img-fluid"></p>

<div class="no-row-height column-margin column-container"><div class="">
<p>This image is an example of a geographic crosswalk - from census tract to census place. We will go into more detail later as to how to use this to approximate data at one geographic level from another.</p>
</div></div></section>
<section id="when-do-i-need-a-crosswalk" class="level2">
<h2 class="anchored" data-anchor-id="when-do-i-need-a-crosswalk">When Do I Need A Crosswalk?</h2>
<section id="we-often-use-geographic-crosswalks-when" class="level5">
<h5 class="anchored" data-anchor-id="we-often-use-geographic-crosswalks-when">We <strong>often use</strong> geographic crosswalks when:</h5>
<ul>
<li>We have multiple data sources at different geographic levels and want to merge those data together by geographic location</li>
<li>We have data at one level of geography but do not have data at the geographic level we want to represent</li>
<li>We want to standardize geographies over time</li>
</ul>
</section>
<section id="we-do-not-need-to-use-geographic-crosswalks-when" class="level5">
<h5 class="anchored" data-anchor-id="we-do-not-need-to-use-geographic-crosswalks-when">We <strong>do not need to use</strong> geographic crosswalks when:</h5>
<ul>
<li><p><strong>Data is available at the geography we need it to be.</strong> It is usually much better to download data at the geography you need it than to go through a geographic crosswalk. This can save some steps and reduce error, especially if your data is not <em>nested</em> (more on that later).</p></li>
<li><p><strong>We have address data and we would like to add information regarding a geographic boundary.</strong> If you have address data, you can do a <em>spatial join</em> instead of using a geographic crosswalk to add geographic information, as long as the geographic data (such as a shapefile) is available. To do so in R, you can use <code>sf::st_join</code> to complete this task.</p></li>
</ul>
</section>
</section>
<section id="is-my-data-nested" class="level2">
<h2 class="anchored" data-anchor-id="is-my-data-nested">Is My Data Nested?</h2>
<p>One of the key things to determine before using a geographic crosswalk is to consider whether the geography of the data you already have is <strong>nested</strong> within the geography that you would like to have. Your geography is <strong>nested</strong> if, when aggregating, it completely and neatly fits within the desired geography.</p>
<p>For example, let’s say you have data at the county level, but would like to represent your data at the state level. Counties are <strong>nested</strong> within states, meaning they completely are encompassed by states and there is complete overlap when aggregating counties to states.</p>
<p><img src="www/images/county_w_legend.png" class="img-fluid"></p>
<p>Nested data is important when using geographic crosswalks because it makes the transformation from one geography to another much more simple.</p>
<p>With data that is not nested, we will need to approximate the area that intersects with the geography you are transforming to.</p>
<p><img src="www/images/zcta_county_plot_w_legend.png" class="img-fluid"></p>
<ul>
<li>The Census Bureau releases all data at a series of 27 different geographic levels.</li>
<li>A key concept is that of <strong>nesting</strong>. Some census geographies are entirely composed of other census geographies, making aggregation from the smaller to the larger geographic level simple.</li>
<li>A chart depicting the 27 geographic levels and their relationships to each other can be seen below.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/censusgeochart.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Image from <a href="https://mcdc.missouri.edu/geography/sumlevs/">MCDC</a></figcaption><p></p>
</figure>
</div>
<ul>
<li>Note that all census blocks are entirely nested within census block groups, census block groups within census tract, tracts in counties, and counties within states</li>
<li>Blocks are generally bounded by visible features or boundaries (like roads!).</li>
</ul>
<section id="background-blocks-block-groups-and-tracts-in-depth" class="level3">
<h3 class="anchored" data-anchor-id="background-blocks-block-groups-and-tracts-in-depth">Background: Blocks, Block Groups, and Tracts in Depth</h3>
<ul>
<li>Blocks are statistical entities that tend to be small and are bounded by visible features (e.g.&nbsp;roads, streams, railroad tracks) or non-visible features like city boundaries.</li>
<li>Block groups are generally defined to contain 600-3000 people.</li>
<li>Census tracts have between 1200 and 8000 people, and often/ideally close to 4000. Census tract boundaries are made to last over time.</li>
<li>Because of these population limitations, these geographic levels can change over time. Such changes necessitate crosswalks.</li>
</ul>
</section>
<section id="tiger-fips-codes-and-when-you-do-not-need-to-use-a-crosswalk" class="level3">
<h3 class="anchored" data-anchor-id="tiger-fips-codes-and-when-you-do-not-need-to-use-a-crosswalk">TIGER, FIPS Codes and When you do not need to use a Crosswalk:</h3>
<ul>
<li><p>The Census Bureau releases spatial data outlining census geography in their TIGER/Line Shapefiles.</p></li>
<li><p>In the TIGER/Line Shapefiles, each geographic unit (e.g.&nbsp;a census tract or block) has a unique geographic identifier, or GEOID.</p></li>
<li><p>GEOIDs have a great naming convention, some of which we outline below.</p></li>
</ul>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>Geographic Level</th>
<th>Structure</th>
<th>Number of Digits</th>
<th style="text-align: right;">Example Area</th>
<th style="text-align: right;">Example GEOID</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>State</td>
<td>STATE</td>
<td>2</td>
<td style="text-align: right;">Texas</td>
<td style="text-align: right;">48</td>
</tr>
<tr class="even">
<td>County</td>
<td>STATE + County</td>
<td>2+3 =5</td>
<td style="text-align: right;">Harris County, Texas</td>
<td style="text-align: right;">48201</td>
</tr>
<tr class="odd">
<td>Tract</td>
<td>STATE + COUNTY + TRACT</td>
<td>2 +3 + 6 = 11</td>
<td style="text-align: right;">Tract 2231 in Harris County, Texas</td>
<td style="text-align: right;">48201223100</td>
</tr>
<tr class="even">
<td>Block Group</td>
<td>STATE + COUNTY + TRACT + BLOCK GROUP</td>
<td>2+3+6+1 = 12</td>
<td style="text-align: right;">Block Group 1 in Census Tract 2231 in Harris County, TX</td>
<td style="text-align: right;">482012231001</td>
</tr>
<tr class="odd">
<td>Block</td>
<td>STATE + COUNTY + TRACT + BLOCK GROUP + BLOCK</td>
<td>2+3+6+4 = 15</td>
<td style="text-align: right;">Block 1050 in Census Tract 2231 in Harris County, TX</td>
<td style="text-align: right;">482012231001050</td>
</tr>
</tbody>
</table>
<p>Example from <a href="https://www.census.gov/programs-surveys/geography/guidance/geo-identifiers.html#:~:text=FIPS%20codes%20are%20assigned%20alphabetically,Native%20Hawaiian%20(AIANNH)%20areas.">The Census</a></p>
<ul>
<li><p>Other geographic levels also follow this scheme, and you can learn more at the link above.</p></li>
<li><p>We list these examples because they show how the naming convention makes use of the fact that these geographies nest within each other.</p></li>
<li><p>This naming scheme means that you do not need a crosswalk to simply aggregate from smaller to larger levels of geography if working with data all at the same geographic scale.</p></li>
<li><p>Instead, you simply need to:</p>
<ol type="1">
<li>Create a new column in your dataframe with the GEOID truncated to the new geographic level.</li>
<li>Group by and summarize the data using the higher geographic scale.</li>
</ol></li>
</ul>
</section>
</section>
<section id="the-knitty-gritty-of-crosswalks" class="level2">
<h2 class="anchored" data-anchor-id="the-knitty-gritty-of-crosswalks">The Knitty-Gritty of Crosswalks</h2>
<section id="definition" class="level3">
<h3 class="anchored" data-anchor-id="definition">Definition:</h3>
<p>A geographic crosswalk is a tabular dataset with at least the following three columns: (1) a source geography - a column that uniquely identifies the geographic scale of the source data (2) the target geography - a column that identifies the geographic coverage which we want to relate to the source areas (3) an interpolation weight (also known as an allocation factor) - a column that identifies the portion of the source area that is located in the target area</p>
<p>Every row in this dataset can be thought of as an “atom.” Each atom is some subdivision of source and target geographic levels.</p>
<p>To crosswalk data from one scale to another, one can use the following algorithm: (1) Join data at the source geography to the geographic crosswalk (using the geographic identifier). (2) Multiply the data to be cross-walked at the source geography by the interpolation weight (3) Sum the data by the target geography</p>
</section>
<section id="example" class="level3">
<h3 class="anchored" data-anchor-id="example">Example:</h3>
<p>The above definition is a bit abstract, so here is an example. Suppose we have data at a fictitious geography “Green.”</p>
<p><insert green="" image=""></insert></p>
<p>Perhaps we hope to transform that data to geographic scale blue (likely to join with other data):</p>
<p><insert blue=""></insert></p>
<p>Overlaying these geographies would lead to the creation of four unique atoms:</p>
<p>A Green-to-Blue crosswalk would allow for the estimation of the data at the green geographic scale to the blue geographic level. The crosswalk could look something like the following:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>  Green Blue Interpolation_Weights
1     A    A                  0.85
2     A    B                  0.15
3     B    B                  0.70
4     B    C                  0.30</code></pre>
</div>
</div>
<p>Note how, for each of the target geometries (Blue), the interpolation weights sum to 1. This shows how the total contribution of each cell in a target geometry sums to 100% of that geometry.</p>
<p>Suppose we have the following data at the green geographic level:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">200</span>, <span class="dv">100</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>geography <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"A"</span>, <span class="st">"B"</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>green_pop <span class="ot">&lt;-</span><span class="fu">data.frame</span>(geography, data)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>green_pop</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  geography data
1         A  200
2         B  100</code></pre>
</div>
</div>
</section>
<section id="examples-in-urban-work" class="level3">
<h3 class="anchored" data-anchor-id="examples-in-urban-work">Examples in Urban Work</h3>
</section>
<section id="sourcesplaces-to-learn-more" class="level3">
<h3 class="anchored" data-anchor-id="sourcesplaces-to-learn-more">Sources/Places to learn more:</h3>
<p>https://www.census.gov/programs-surveys/geography/about/glossary.html#par_textimage_5 https://www.census.gov/content/dam/Census/data/developers/geoareaconcepts.pdf https://mcdc.missouri.edu/geography/sumlevs/ https://datadrivendetroit.org/blog/2021/09/16/2020-census-tract-changes/ https://mcdc.missouri.edu/applications/docs/geocorr2022-help.html#afact2</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>